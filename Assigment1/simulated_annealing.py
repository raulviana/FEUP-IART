import math
import random

from objective import *
from utils import *


def simulated_annealing(photos, SA_temp, SA_min_temp, SA_cool_rate, SA_it_per_temp):
    import time
    start_time = time.process_time()
    s = generate_slides(photos) #generate slides, sorted by horizontal and then vertical
    solution = organize_slides(s)
    score = ObjectiveFunction(solution)

    temp = SA_temp
    initial_temp = temp
    temp_min = SA_min_temp
    cooling_rate = SA_cool_rate
    itPerTemp = SA_it_per_temp


    while temp > temp_min:
        it = 0

        while it < itPerTemp:
            new_solution = addOperator(solution)
            new_score = ObjectiveFunction(new_solution) #para dar positivo
            
            if new_score >= score: #so > diminui mt o nr de pontos,
                solution = new_solution
                score = new_score
            else:
                accProbability = acceptanceProbability(score, new_score, temp)
                if accProbability > random.random():
                    solution = new_solution
                    score = new_score

            print(score)
            it = it + 1


        temp = temp-cooling_rate

    print("--------------------")
    print("Simulated Annealing")
    print(" ")
    print("Score: ", score) 
    print("With ", initial_temp, " of temperature and ", cooling_rate, " of cooling rate")
    time = time.process_time() - start_time
    print("In %.3f seconds of processor time" % time)
    return new_solution


def acceptanceProbability(score, new_score, temp):
    loss = abs(new_score-score)
    return math.exp(-(loss/temp))


def addRandomOperator(slides):
    #For example, in the travelling salesman problem each state is typically defined as a
    # permutation of the cities to be visited, and its neighbours are the set of permutations
    # produced by reversing the order of any two successive cities.
    # A new solution is generated by inverting the "place" of two successive images
    length = len(slides)-1-1 #[0,length-1] -> nao seleciona o ultimo
    idx = random.randrange(0, length)
    swapPositions(slides, idx, idx+1)

    return slides

def addOperator(slides):
    copy = slides.copy()

    length = len(copy)-1-1 #para nao apanhar o ultimo >>> por causa do swap
    idx = random.randrange(0, length)

    s = copy[idx]
    score = 0

    i = len(copy)-1

    for s1 in reversed(copy):
        new_score = s.interest(s1)
        if new_score > score:
            new_i = i
        score = new_score
        i = i-1

    swapPositions(copy, new_i, idx+1)
    return copy


def swapPositions(slides, pos1, pos2):
    slides[pos1], slides[pos2] = slides[pos2], slides[pos1]
    return slides


def organize_slides(slides):
    sol = sorted(slides, key=lambda x: x.getNrTags(), reverse=True) #ordenar por ordem crescente de nr de tags
    return sol